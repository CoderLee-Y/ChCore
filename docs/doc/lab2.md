# Report on lab 2

李逸岩, 519021911103, `lyy0627@sjtu.edu.cn`

## 1

多级页表优势是占用很少内存时节约内存空间，如果虚拟地址空间中有大量未使用区域，可以通过在省略高级页表的描述符来避免低级页表占据内存空间。劣势是需要访问多次内存查询页表，且在虚拟地址空间占用较多的场景下更耗费内存。(这也是TLB和大页出现的理由。)

- 4 KB大小映射：说明是4级页表结构。L3需要 `1024 * 1024`个条目，需要`2048`个页。L2需要`2048` 个条目，`4` 个页。而L0, L1都仅需要`1`页。最终，需要`2054`个额外的页表页。
- 2 MB大小映射：说明是3级页表结构。L2 需要`2048` 个条目，需要`4`个页，L0, L1都仅需要`1`页。最终需要`6`个额外的页表页。

## 2

和例子中给定的低地址映射类似，先设定L0/L1的页表（他们只有一个PTE），再设定L2的页表。最主要的变化是`Vaddr = Paddr + KERNEL_VADDR`. 运行后，测试后续伙伴系统的代码将自动运行，程序将不会在`0x200`处崩溃。（在这过程中还发现了之前Lab 1留下的Bug，即在从EL3跳转到EL1时忽略了注释的提示，而是直接写了`isb / eret`）

## 3

保证低地址和高地址是完全相同的，这样在启动MMU但是还没有切换到高地址空间的时候我们还能正常访问物理内存。因为在enable mmu之后，内存访问必须经过MMU翻译。在`el1_mmu_activate`结束前，SP, PC是物理地址。所以必须设置低地址页表。

实验结果如下，我们注释掉对应的映射低地址代码，运行程序。可以看到，在Commit point之后的第一条指令PC就无法正常被翻译，函数无法继续执行。

<img src="https://s2.loli.net/2022/03/10/hCaizoIePD2jLyW.png" alt="2022-03-10 09-13-43 的屏幕截图" style="zoom:80%;" />

`info registers`可以看到PC, SP都在低地址空间，这是不可避免的，因为函数必须恢复特殊寄存器才能返回，而同一个函数的SP, PC都只能是一套。MMU_ACTIVATE之前使用的是物理地址，之后也是。

<img src="https://s2.loli.net/2022/03/10/BxkMf8iaOP23n7q.png" alt="2022-03-10 09-31-38 的屏幕截图" style="zoom:67%;" />

## 4

实现的时候注意维持的不变量包括：

- Mem Area内的所有`page meta` 应该和这块内存的`Head Page meta `一样
- 在`free list`中的Head Page `allocated == 0`
- `free_list`中的节点数量应该等于`nr_free`
- `merge/split `的输入应该在`free list`中, 输出应该仍然在`free list`中 (保证作为工具函数的正确性)

主要的Bug就是`buddy_get_pages`中在调用了`spilt page`的时候，`pool->free_lists[page->order].nr_free--;`写为了`pool->free_lists[i].nr_free--;`。即改为了最初分配的大块的内存对应的`nr_free`. 这违反了第三条不变量。最终运行结果：

<img src="/home/lee/图片/2022-03-10 20-11-43 的屏幕截图.png" alt="2022-03-10 20-11-43 的屏幕截图" style="zoom:67%;" />

## 5

主要解决的Bug就是没有注意读ptp_t, 直接以为这是pte_t指针的typedef, 正确用法是`next_pte = &(next_ptp->ent[GET_L3_INDEX(*va*)])`. 主要实现思路就是利用`get_next_ptp`逐级的查询并验证PTE类型，利用位运算组装物理地址。

<img src="/home/lee/图片/2022-03-11 16-24-20 的屏幕截图.png" alt="2022-03-11 16-24-20 的屏幕截图" style="zoom:50%;" />



## 6

添加了对大页的支持。需要注意的是前后对其要求。实现目标是尽可能的分配大页同时减小内部碎片的占比。整个实现分为五段，可能实际运行[1, 5]段。下面过程叙述都保证始末VA在`VA-VA+len`内。

- `start_va - 对齐2M的第一个地址` 使用4K页
- `对齐2M的第一个地址 - 对齐1G的第一个地址` 2M大页
- `对齐1G的第一个地址 - 对齐1G的最后一个地址` 1G大页
- `对齐1G的最后一个地址 - 对齐2M的最后一个地址` 2M大页
- `对齐2M的最后一个地址 - 尾地址` 4K页

<img src="/home/lee/图片/2022-03-11 20-07-34 的屏幕截图.png" alt="2022-03-11 20-07-34 的屏幕截图" style="zoom:67%;" />

## 7

应用程序以只读的方式共享一段内存，如果某个应用程序想对内存进行修改，就会触发缺页异常(实际上由Permission Fault导致)。然后控制流转到Handler之后发现缺页异常是因为写只读内存导致的，而这些内存又被标记为CoW的。于是OS会将对应的物理页重新拷贝一份，新拷贝的物理页将置可写位为1. 然后将这个映射给触发PF的进程，然后就可以修改这个物理页了。完成了一次写时拷贝。                                                                              

##                                                                                                                                 8





## 9





