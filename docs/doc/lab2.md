# Report on lab 2

李逸岩, 519021911103, `lyy0627@sjtu.edu.cn`

## 1

多级页表优势是占用很少内存时节约内存空间，如果虚拟地址空间中有大量未使用区域，可以通过在省略高级页表的描述符来避免低级页表占据内存空间。劣势是需要访问多次内存查询页表，且在虚拟地址空间占用较多的场景下更耗费内存。(这也是TLB和大页出现的理由。)

- 4 KB大小映射：说明是4级页表结构。L3需要 `1024 * 1024`个条目，需要`2048`个页。L2需要`2048` 个条目，`4` 个页。而L0, L1都仅需要`1`页。最终，需要`2054`个额外的页表页。
- 2 MB大小映射：说明是3级页表结构。L2 需要`2048` 个条目，需要`4`个页，L0, L1都仅需要`1`页。最终需要`6`个额外的页表页。

## 2

和例子中给定的低地址映射类似，先设定L0/L1的页表（他们只有一个PTE），再设定L2的页表。最主要的变化是`Vaddr = Paddr + KERNEL_VADDR`. 运行后，测试后续伙伴系统的代码将自动运行，程序将不会在`0x200`处崩溃。（在这过程中还发现了之前Lab 1留下的Bug，即在从EL3跳转到EL1时忽略了注释的提示，而是直接写了`isb / eret`）

## 3

保证低地址和高地址是完全相同的，这样在启动MMU但是还没有切换到高地址空间的时候我们还能正常访问物理内存。因为在enable mmu之后，内存访问必须经过MMU翻译。在`el1_mmu_activate`结束前，SP, PC是物理地址。所以必须设置低地址页表。

实验结果如下，我们注释掉对应的映射低地址代码，运行程序。可以看到，在Commit point之后的第一条指令PC就无法正常被翻译，函数无法继续执行。

<img src="https://s2.loli.net/2022/03/10/hCaizoIePD2jLyW.png" alt="2022-03-10 09-13-43 的屏幕截图" style="zoom:80%;" />

## 4





## 5



## 6



## 7



## 8





## 9

