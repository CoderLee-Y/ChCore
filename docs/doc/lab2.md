# Report on lab 2

李逸岩, 519021911103, `lyy0627@sjtu.edu.cn`

## 1

多级页表优势是占用很少内存时节约内存空间，如果虚拟地址空间中有大量未使用区域，可以通过在省略高级页表的描述符来避免低级页表占据内存空间。劣势是需要访问多次内存查询页表，且在虚拟地址空间占用较多的场景下更耗费内存。(这也是TLB和大页出现的理由。)

- 4 KB大小映射：说明是4级页表结构。L3需要 `1024 * 1024`个条目，需要`2048`个页。L2需要`2048` 个条目，`4` 个页。而L0, L1都仅需要`1`页。最终，需要`2054`个额外的页表页。
- 2 MB大小映射：说明是3级页表结构。L2 需要`2048` 个条目，需要`4`个页，L0, L1都仅需要`1`页。最终需要`6`个额外的页表页。

## 2

和例子中给定的低地址映射类似，先设定L0/L1的页表（他们只有一个PTE），再设定L2的页表。最主要的变化是`Vaddr = Paddr + KERNEL_VADDR`. 运行后，测试后续伙伴系统的代码将自动运行，程序将不会在`0x200`处崩溃。（在这过程中还发现了之前Lab 1留下的Bug，即在从EL3跳转到EL1时忽略了注释的提示，而是直接写了`isb / eret`）

## 3

保证低地址和高地址是完全相同的，这样在启动MMU但是还没有切换到高地址空间的时候我们还能正常访问物理内存。因为在enable mmu之后，内存访问必须经过MMU翻译。在`el1_mmu_activate`结束前，SP, PC是物理地址。所以必须设置低地址页表。

实验结果如下，我们注释掉对应的映射低地址代码，运行程序。可以看到，在Commit point之后的第一条指令PC就无法正常被翻译，函数无法继续执行。

<img src="https://s2.loli.net/2022/03/10/hCaizoIePD2jLyW.png" alt="2022-03-10 09-13-43 的屏幕截图" style="zoom:80%;" />

`info registers`可以看到PC, SP都在低地址空间，这是不可避免的，因为函数必须恢复特殊寄存器才能返回，而同一个函数的SP, PC都只能是一套。MMU_ACTIVATE之前使用的是物理地址，之后也是。

<img src="https://s2.loli.net/2022/03/10/BxkMf8iaOP23n7q.png" alt="2022-03-10 09-31-38 的屏幕截图" style="zoom:67%;" />

## 4

实现的时候注意维持的不变量包括：

- Mem Area内的所有`page meta` 应该和这块内存的`Head Page meta `一样
- 在`free list`中的Head Page `allocated == 0`
- `free_list`中的节点数量应该等于`nr_free`
- `merge/split `的输入应该在`free list`中, 输出应该仍然在`free list`中 (保证作为工具函数的正确性)

主要的Bug就是`buddy_get_pages`中在调用了`spilt page`的时候，`pool->free_lists[page->order].nr_free--;`写为了`pool->free_lists[i].nr_free--;`。即改为了最初分配的大块的内存对应的`nr_free`. 这违反了第三条不变量。最终运行结果：

<img src="/home/lee/图片/2022-03-10 20-11-43 的屏幕截图.png" alt="2022-03-10 20-11-43 的屏幕截图" style="zoom:67%;" />

## 5





## 6





## 7





## 8





## 9





